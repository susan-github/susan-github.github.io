<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[防坑手册]]></title>
    <url>%2Fanti-pit%2F</url>
    <content type="text"><![CDATA[前言Coding完的时候，总是蜜汁自信地觉得，我怎么这么牛*，这么复杂的逻辑都写出来了，提测后，会遇到各色各样的bug。然后debug了半天，恨不得骂自己一句：“傻*”。这不怪你，谁让js是世界上最牛*的语言，前端开发是宇宙中最牛*的职业呢，遇到点坑算啥，在同一个坑了跌倒两次才是真正的傻*。 Array.prototype.sort() arr.sort([compareFunction]) sort()如果没有指明 compareFunction ，那么元素会按照转换为的字符串的诸个字符的Unicode位点进行排序。错误的写法：1234const array1 = [2, 1];console.log(array1.sort()); // [1, 2]const array2 = [2, 11];console.log(array2.sort()); // [11, 2] 正确的写法：123const array = [2, 11];const sortArray = array.sort((a, b) =&gt; a - b);console.log(sortArray); // [2, 11]]]></content>
  </entry>
  <entry>
    <title><![CDATA[express-session关键源码解读]]></title>
    <url>%2Fsession%2F</url>
    <content type="text"><![CDATA[背景有个测试的同学可能在搞自动化测试还是啥的，然后想要用python调网关接口，但是一直调不通，问我需要携带哪些信息，可以通过校验。我跟她说请求时携带用户信息和登录的auth信息就可以了，结果发现还是不想，网关的session信息一直是空的。一开始想的是跨域，导致没有携带cookie，让测试配置credentials: ‘include’(参考文章)，对python一窍不通的两人，不知道python咋设置，后来就干脆直接写了个接口/api/getCookie让测试拿cookie，手动设置请求头的cookie，最后发现session还是为空，因为请求既然已经带着cookie了，那一定是根据这个cookie里的sessionId去查找，测试在调/api/getCookie是没有设置session的，走接下来的流程，肯定还是空的，最终改成在调/api/getCookie接口是，先设置下session，后期session如果有更新，再去更新store。 虽然方法有点挫，但是不能妨碍我学习的脚步。update: 之前一直有疑惑，为啥测试调我开发环境可以，调测试环境不行，还不报错，今天空下来，写了个python请求的demo，发现之前认知的偏差。压根就不是python不能携带cookie引发的一系列骚操作，而是因为网关层某个session值在replace之前没有设置，然后，然后抛异常了。。。。没看到异常日志，只怪我太瞎了。 之所以道路那么曲折，还不是因为对基础不扎实，对第三方库不熟悉，所以仔细的看了下session相关的文章，以及express-session源码。虽然道路曲折，但是也算有所收获了~~~ 服务端创建Session 生成唯一标识sessionID，tomacat生成的key为jsessionid 开辟数据存储空间，一般会在内存中创建相应的数据结构，当然也可以将其持久化存储在数据库或者redis中 将唯一标识发送给客户端，将其设置在响应头、响应体等，一般采用两种方式：cookie和URL重写(url重写不做介绍) 以上就是创建Session的过程，支持cookie的浏览器，会创建cookie文件并保存，在判断cookie未过期且credentials设置成允许发送cookie的情况下，在每次请求时，都会将cookie设置在Request Header中，将其发送到服务端，服务端根据获取到的唯一标识，去数据存储空间查找相应的数据，从而服务端能根据存储的数据进入到正常的业务流转。 express-session(v1.15.6)关键源码解读1234567891011app.use(session(&#123; store: sessionStore, // session的存储方式，默认存放在内存中，也可以使用redis，mongodb等 secret: '123456', // 通过设置的secret字符串，来计算hash值并放在cookie中，使产生的signedCookie防篡改 name: 'demo_sid', // 设置cookie，保存session的字段名称，默认为connect.sid resave: false, // 即使session没有被修改，也保存session值，默认为true。 saveUninitialized: false, // 待查阅 cookie: &#123; // 设置存放sessionID的cookie的相关选项，默认为(default: &#123; path: '/', httpOnly: true, secure: false, maxAge: null &#125;) secure: false, maxAge: MAX_AGE, &#125;,&#125;)); 以上为express-session的基本配置，接下来对照源码，来解释一下express-session具体都干了些啥。 一、生成唯一标识sessionID 123456789101112131415161718192021222324252627282930313233343536// index.jsfunction generateSessionId(sess) &#123; return uid(24);&#125;function session(options) &#123; var opts = options || &#123;&#125; var cookieOptions = opts.cookie || &#123;&#125; var generateId = opts.genid || generateSessionId ... store.generate = function(req)&#123; req.sessionID = generateId(req); req.session = new Session(req); req.session.cookie = new Cookie(cookieOptions); if (cookieOptions.secure === 'auto') &#123; req.session.cookie.secure = issecure(req, trustProxy); &#125; &#125;; ... var cookieId = req.sessionID = getcookie(req, name, secrets); ... function generate() &#123; store.generate(req); originalId = req.sessionID; originalHash = hash(req.session); wrapmethods(req.session); &#125; ... if (!req.sessionID) &#123; debug('no SID sent, generating session'); generate(); // 逻辑入口 next(); return; &#125;&#125; 不难在express-session的index.js文件中看到, 通过getcookie方法获取到sessionID, 将其赋值给req.sessionID, 然后判断是否为空，是，则调用generate, generate-&gt;store.generate-&gt;调用generateSessionId方法, 生成长度为24位的唯一ID, 并赋值给req.sessionID。 二、存储session信息到store 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// index.jsfunction session(options) &#123; ... var store = opts.store || new MemoryStore() ... store.generate = function(req)&#123; ... req.session = new Session(req); ... &#125;; ... req.sessionStore = store; // store可以是options传入的store，或者MemoryStore，req.sessionStore供session.js里save方法中调用set方法使用 ... ... // 逻辑入口 if (shouldSave(req)) &#123; req.session.save(function onsave(err) &#123; // 调用session.js的save方法 if (err) &#123; defer(next, err); &#125; writeend(); &#125;); return writetop(); &#125; else if &#123; ... &#125; ... // determine if session should be saved to store function shouldSave(req) &#123; // cannot set cookie without a session ID if (typeof req.sessionID !== 'string') &#123; debug('session ignored because of bogus req.sessionID %o', req.sessionID); return false; &#125; return !saveUninitializedSession &amp;&amp; cookieId !== req.sessionID ? isModified(req.session) : !isSaved(req.session) &#125;&#125;// session.jsdefineMethod(Session.prototype, 'save', function save(fn) &#123; this.req.sessionStore.set(this.id, this, fn || function()&#123;&#125;); return this;&#125;); 通过shouldSave方法判断，是否是新的session或者session是否被修改过，是则调用store的set方法，进行存储。 三、设置set-cookie响应头 123456789101112131415161718192021// index.jsvar cookie = require('cookie')var onHeaders = require('on-headers') // 即将写入请求头时，执行一个监听器var signature = require('cookie-signature')function setcookie(res, name, val, secret, options) &#123; var signed = 's:' + signature.sign(val, secret); var data = cookie.serialize(name, signed, options); debug('set-cookie %s', data); var prev = res.getHeader('set-cookie') || []; var header = Array.isArray(prev) ? prev.concat(data) : [prev, data]; res.setHeader('set-cookie', header)&#125;onHeaders(res, function()&#123; ... // 逻辑入口 setcookie(res, name, req.sessionID, secrets[0], req.session.cookie.data);&#125;) 通过一个监听器，将通过req.sessionID和secret加密过的字段序列化之后，设置到响应头的set-cookie字段，供客户端使用 四、从store中读取session信息，并将其赋值给req.session 12345678910111213141516171819202122232425262728293031323334353637383940// index.jsfunction session(options) &#123; ... var store = opts.store || new MemoryStore() ... var cookieId = req.sessionID = getcookie(req, name, secrets); ... if (!req.sessionID) &#123; debug('no SID sent, generating session'); generate(); next(); return; &#125; // 逻辑入口 store.get(req.sessionID, function(err, sess)&#123; ... else &#123; debug('session found'); store.createSession(req, sess); // 从store中读取出session信息，并将其写入req.session originalId = req.sessionID; originalHash = hash(sess); if (!resaveSession) &#123; savedHash = originalHash &#125; wrapmethods(req.session); &#125; &#125;)&#125;// store.jsStore.prototype.createSession = function(req, sess)&#123; var expires = sess.cookie.expires , orig = sess.cookie.originalMaxAge; sess.cookie = new Cookie(sess.cookie); if ('string' == typeof expires) sess.cookie.expires = new Date(expires); sess.cookie.originalMaxAge = orig; req.session = new Session(req, sess); return req.session;&#125;; 如果req.sessionID存在，则从store中读取session信息，并将其写入req.session。注: 1.5.0以下版本，需要使用cookie-parser中间件将cookie解析成object，1.5.0以上版本express-session内部会调用cookie模块的parse方法，直接对请求的cookie进行读写，所以最好不要使用cookie-parse中间，避免由于secret加解密方式不同造成影响。 参考文章express框架之session]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>session</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跨域预检请求]]></title>
    <url>%2Fcors%2F</url>
    <content type="text"><![CDATA[前言遇到问题的过程中，很多人优先想到的是如何去解决，而不是说为什么会出现这种现象，毕竟留给程序员的时间不多，就把”为什么”留给空下来的时候，再去好好研究吧，然后留着留着就忘记这一茬了。当然，以上仅代表个人观点，因为我就是这样的人，现在，我决定把某一茬捡起来。 背景有一天，有个同事遇到个问题(具体啥问题记不清了)，然后找另外一个同事帮她看，然后另外一个同事说：你不知道跨域访问，会有一个OPTIONS的请求么？我在旁边听到的时候，心想：我知道会有个OPTIONS，但是为什么呢？ CORS跨域请求 跨域资源共享(CORS) 是一种机制，它使用额外的 HTTP 头来告诉浏览器 让运行在一个 origin (domain) 上的Web应用被准许访问来自不同源服务器上的指定的资源。当一个资源从与该资源本身所在的服务器不同的域、协议或端口请求一个资源时，资源会发起一个跨域 HTTP 请求。 简而言之，当一个请求url的协议、域名、端口三者之间任意一与当前页面地址不同即为跨域。 OPTIONS预检请求有人可能会提出疑问，一个html页面引入第三方库(比如jQuery: https://code.jquery.com/jquery-3.3.1.min.js)，不也是跨域么？怎么就不会出现OPTIONS方式的请求呢？跟着我来一步一步解决疑惑。在介绍预检请求时，我们将请求分为两种类型：简单请求和预检请求 简单请求一些请求被称为简单请求，它们不会触发预检，需要满足以下条件： 请求方法仅限于下列三者之一： GET HEAD POST 请求头仅限于以下字段的集合： Accept Accept-Language Content-language Content-Type(仅限于下一项三者之一) Last-Event-ID DPR Save-Data Viewport-Width Width Content-Type仅限于下列三者之一 application/x-www-form-urlencoded multipart/form-data text/plain 请求中的XMLHttpRequestUpload对象均没有注册任何事件监听器 请求中没有使用 ReadableStream 对象 预检请求如果请求不满足以上标准，浏览器会在实际请求之前，自动发送一个OPTIONS请求，以获知该请求是否被服务器允许且是否安全。例如DELETE、PUT等会修改数据的请求方式，或者Content-Type是application/json的请求，都会发送预检请求。 举个实际项目中跨域请求的例子，请求头中多携带一个DAdditional-info字段，同样为网关层的响应头Access-Control-Allow-Headers字段添加DAdditional-info。12345678910// http://192.168.103.111:3000fetch('http://192.168.103.111:9000/api/shop/fee', &#123; method: 'GET', headers: &#123; 'DAdditional-info': 'UserId/6891221 CityId/1' &#125;, credentials: 'include', &#125;).then(response =&gt; response.json()).then(resp =&gt; &#123; console.log('response:' + JSON.stringify(resp)) &#125;) 12345678910// http://192.168.103.111:9000import Express from 'express'const app = Express();app.all('*', (req, res, next) =&gt; &#123; res.header('Access-Control-Allow-Origin', req.headers.origin); res.header('Access-Control-Allow-Headers', 'Content-Type,user-code,X-Requested-With,User-Agent,Authorization,DAdditional-info'); res.header('Access-Control-Allow-Credentials', 'true'); res.header('Access-Control-Allow-Methods', 'GET,POST,OPTIONS'); next();&#125;); 如果Access-Control-Allow-Headers没有设置DAdditional-info，浏览器控制台会报Access to fetch at &#39;http://192.168.103.111:9000/api/shop/fee&#39; from origin &#39;http://192.168.103.111:3000&#39; has been blocked by CORS policy: Request header field dadditional-info is not allowed by Access-Control-Allow-Headers in preflight response.，有兴趣可以自己尝试一下。 通过Chrome的Network可以观察到有两条请求记录，一条Method是OPTIONS，一条是GET。来看下OPTIONS的Request Header和Response Header部分。 Access-Control-Request-Method告知服务器，实际请求将以GET的方式，Access-Control-Request-Headers告知服务器，实际请求将携带自定义请求头字段DAdditional-info. 服务器允许客户端采用GET方式，且允许客户端请求中携带DAdditional-info字段。 客户端发起实际GET请求，请求头携带DAdditional-info以及Cookie(后续会请求头Cookie的设置) 服务器返回请求结果 所以，这就解释了前面提到的html中引入第三方库，浏览器没有主动发起一个OPTIONS的请求了。 跨域请求携带Cookie上一个列子中看到，为请求头设置了credentials: &#39;include&#39;, 为响应头设置Access-Control-Allow-Credentials: &#39;true&#39;, 请求头携带了Cookie字段, 请求结果也能正常返回，接下来说说credentials。 credentials 是Request接口的只读属性，用于表示用户代理是否应该在跨域请求的情况下从其他域发送cookies。这与XHR的withCredentials 标志相似，不同的是有三个可选值（后者是两个）：omit: 从不发送cookies.same-origin: 只有当URL与响应脚本同源才发送 cookies、 HTTP Basic authentication 等验证信息.(浏览器默认值,在旧版本浏览器，例如safari 11依旧是omit，safari 12已更改)include: 不论是不是跨域的请求,总是发送请求资源域在本地的 cookies、 HTTP Basic authentication 等验证信息. When a request’s credentials mode (Request.credentials) is “include”, browsers will only expose the response to frontend JavaScript code if the Access-Control-Allow-Credentials value is true. 当请求头设置了include之后，服务器必须设置Access-Control-Allow-Credentials为true，否则浏览器不会返回结果给客户端。Chrome浏览器会提示The value of the &#39;Access-Control-Allow-Credentials&#39; header in the response is &#39;&#39; which must be &#39;true&#39; when the request&#39;s credentials mode is &#39;include&#39;. 如果Access-Control-Allow-Credentials是作为OPTIONS预检请求的一个字段，则它指代实际请求能否通过credentials进行请求。 Postman mockServer如何解决跨域问题？还不会利用Postman创建一个mockServer的同学，请移步这里。使用以上的例子(携带credentials)，去请求mockServer时，会发现调不通，浏览器提示The value of the &#39;Access-Control-Allow-Origin&#39; header in the response must not be the wildcard &#39;*&#39; when the request&#39;s credentials mode is &#39;include&#39;。尝试了一下修改Response Header的Access-Control-Allow-Origin为mock地址，但是对于OPTIONS预检请求不起作用，所以最后只能使用比较low的方式，将credentials注释掉。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>CORS跨域</tag>
        <tag>OPTIONS预检请求</tag>
        <tag>Postman请求工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript浮点数存储及误差问题]]></title>
    <url>%2Ffloat%2F</url>
    <content type="text"><![CDATA[背景钉钉告警群不断提示”批量支付不支持调整金额”，但是按照正常的业务逻辑，批量支付根本不会出现调整金额的入口。由于该需求非本人开发的，也没放在心上，后来在聊天过程中，聊到是因为前端参数将元-&gt;分(如9956.8*100=995679.9999999999)传给网关及服务的时候，服务做了兜底，判断前端传的价格跟服务不一致，则判定为调整过金额了，尴了个尬。虽然很早就知道js进行四则计算会有精度问题，但是一直没遇到过，项目中也没有对计算做特殊处理，刚好趁这个机会记录一下。 二进制与十进制之前的相互转换先来一起复习一下，二进制和十进制是如何进行转换的，二进制转十进制比较简单，以小数点为分界线210、29…20小数点右边2-1、2-2…十进制转二进制就比较复杂，要区分整数和小数分别计算。 二进制转换成十进制按权相加法，有计算机基础的一看栗子应该就能回忆起来了：110.001 1 x 22 + 1 x 21 + 0 x 20 + 0 x 2-1 + 0 x 2-2 + 1 x 2-3 = 6.125. 即(110.001)2 = (6.125)10 十进制转换成二进制十进制转二进制整数和小数的计算方法不一样，分别计算后合并：173.8125（引用网上的两张图片）整数部分小数部分即(173.8125)10 = (10101101.1101)2 0.1 + 0.2学习了以上的计算方式，不难明白0.1+0.2为啥不等于0.3了，有兴趣但是想偷懒的同学可以直接去在线转换平台测试，计算结果是否为0.30000000000000004。12345// 0.1 和 0.2 都转化成二进制后再进行运算0.00011001100110011001100110011001100110011001100110011010 +0.0011001100110011001100110011001100110011001100110011010 =0.0100110011001100110011001100110011001100110011001100111// 转成十进制正好是 0.30000000000000004 解决方式可以对【计算结果】采用toPrecision(返回指定精度的字符串)，再使用parseFloat将其转为浮点型1parseFloat(0.30000000000000004.toPrecision(12)) === 0.3 // true 在+、-、*、/ 四则运算过程中，可以给Number定义以下方法并调用 加法 12345678910function plus(arg1, arg2)&#123; var r1, r2, m; try&#123; r1 = arg1.toString().split(".")[1].length &#125;catch(e)&#123; r1=0 &#125; try&#123; r2 = arg2.toString().split(".")[1].length &#125;catch(e)&#123; r2=0 &#125; m = Math.pow(10, Math.max(r1,r2)) return (arg1 * m + arg2 * m) / m&#125;Number.prototype.plus = function(arg)&#123; return plus(this, arg) &#125;// 例子0.1.plus(0.2).plus(0.3) // 0.1 + 0.2 + 0.3 = 0.6 减法 1234567891011function minus(arg1, arg2)&#123; var r1, r2, m, n; try&#123; r1 = arg1.toString().split(".")[1].length &#125;catch(e)&#123; r1=0 &#125; try&#123; r2 = arg2.toString().split(".")[1].length &#125;catch(e)&#123; r2=0 &#125; m = Math.pow(10, Math.max(r1,r2)) n = Math.max(r1, r2) return parseFloat(((arg1 * m - arg2 * m) / m).toFixed(n))&#125;Number.prototype.minus = function(arg)&#123; return minus(this, arg) &#125;// 例子0.1.minus(0.2).minus(0.3) // 0.1 - 0.2 - 0.3 = -0.4 乘法 12345678910function mul(arg1, arg2)&#123; var m = 0, s1 = arg1.toString(), s2 = arg2.toString(); try&#123; m += s1.split(".")[1].length &#125;catch(e)&#123;&#125; try&#123; m += s2.split(".")[1].length &#125;catch(e)&#123;&#125; return Number(s1.replace(".", "")) * Number(s2.replace(".", "")) / Math.pow(10, m)&#125;Number.prototype.mul = function(arg)&#123; return mul(this, arg) &#125;// 例子0.1.mul(0.2).mul(0.3) // 0.1 * 0.2 * 0.3 = -0.006 除法 123456789101112function div(arg1, arg2)&#123; var t1 = 0, t2 = 0, r1, r2; try&#123; t1 = arg1.toString().split(".")[1].length &#125;catch(e)&#123;&#125; try&#123; t2 = arg2.toString().split(".")[1].length &#125;catch(e)&#123;&#125; r1 = Number(arg1.toString().replace(".","")) r2 = Number(arg2.toString().replace(".","")) return mul((r1 / r2), Math.pow(10, t2 - t1)) // 由于r1/r2可能出现浮点数，所以需要用mul方法&#125;Number.prototype.div = function(arg)&#123; return div(this, arg) &#125;// 例子0.4.div(0.2).div(0.2) // 0.4 / 0.2 / 0.1 = 20 toFixed()四舍五入精度误差1.005.toFixed(2) 返回的是 1.00 而不是 1.011.005 实际对应的数字是 1.0049999999999998…，这里不对浮点数在内存中如何存储及如何造成精度丢失做过多介绍，有兴趣的同学可以参考这里(说实话，我推导了半天 ，算出来的还是0.1)。我们就使用1.005.toPrecision(32)查看结果为1.0049999999999998934185896359850，4 &lt; 5 被四舍五入舍弃了，所以就不难解释结果为什么是1.00了. 所以如何解决toFixed()的精度问题呢？ 解决方式一：转换成指数形式 很多人会说那就不要用toFixed()方法，用Math.round()吧，Math.round()相对稳定些，然后采用类似Math.round(num * Math.pow(10, s)) / Math.pow(10, s)，但是拿1.005来说，1.005 * 100 = 100.49999999999999，结果还是1.网上看到有一个类似以上方法的解决方案, 先将变量转换成指数形式以后，再进行运算，感觉挺靠谱的，起码出现误差的都能正确计算。12345Number(Math.round(1.005+'e2')+'e-2'); // 1.01// 写成方法function round(value, decimals) &#123; return Number(Math.round(value+'e'+decimals)+'e-'+decimals);&#125; 解决方式二：重写toFixed()方法12345678910111213141516171819202122232425Number.prototype.toFixed=function (d) &#123; var s=this+""; if(!d)d=0; if(s.indexOf(".")==-1)s+="."; s+=new Array(d+1).join("0"); if(new RegExp("^(-|\\+)?(\\d+(\\.\\d&#123;0,"+(d+1)+"&#125;)?)\\d*$").test(s))&#123; var s="0"+RegExp.$2,pm=RegExp.$1,a=RegExp.$3.length,b=true; if(a==d+2)&#123; a=s.match(/\d/g); if(parseInt(a[a.length-1])&gt;4)&#123; for(var i=a.length-2;i&gt;=0;i--)&#123; a[i]=parseInt(a[i])+1; if(a[i]==10)&#123; a[i]=0; b=i!=1; &#125;else break; &#125; &#125; s=a.join("").replace(new RegExp("(\\d+)(\\d&#123;"+d+"&#125;)\\d$"),"$1.$2"); &#125;if(b)s=s.substr(1); return (pm+s).replace(/\.$/,""); &#125;return this+""; &#125;; 解决方式三：使用各种第三方库（推荐大家一个工具，它提供node环境，几乎包含npm上的所有包） math.js12var math = require('mathjs')math.round(1.005, 2) // 1.01 number-precision12var NP = require('number-precision')NP.round(1.005, 2) // 1.01 big.js123var Big = require('big.js');var result = new Big(1.005)result.toFixed(2) // 1.01 decimal.js123var Decimal = require("decimal.js")var x = new Decimal(1.005)x.toFixed(2) // 1.01 bignumber.js123var BigNumber = require('bignumber.js');var x = new BigNumber(1.005)x.toFixed(2) // 1.01 参考文章js浮点数存储精度丢失原理Rounding Decimals in JavaScript]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>浮点数</tag>
        <tag>toPrecision</tag>
        <tag>math.js</tag>
        <tag>bignumber.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jest + enzyme 前端测试入门]]></title>
    <url>%2Ftesting%2F</url>
    <content type="text"><![CDATA[留给程序员的时间，永远都不够开发的，哪有时间写单元测试？为什么要选Jest作为单元测试框架？单元测试有啥用？先说说我是怎么就心血来潮的开始写单元测试的吧，作为一枚新时代前端，除了会写页面布局和交互，还要会用nodejs写网关去调服务组的服务。有一天跟某个服务组联调的时候，就很奇怪，发出去的请求，有时候能调通，有时候不行（大概是三四次会有一次成功吧）然后就问了下服务是什么情况？服务的回复是，因为他们组的人本地都启了服务，然后由于dubbo服务的负载均衡，会随机请求到开发环境及本地服务器。 由于服务应用大，多人开发，网关作为下游，联调成本太高，如果他们还喜欢打断点，那不是GG了。不懂服务的小白就屁颠屁颠地问了下别的组，那位程序员骄傲且自豪地说：我们本地基本都不启动服务的，盲写高质量代码，写完直接跑单元测试模拟网关请求，全部过了，基本上就没啥问题了。听上去他们组的人都非常牛叉哄哄的，但是透过本质看到的是除了代码质量，更加NB的是单元测试有没有。 在进入正题之前，先理解一下，前端测试需要测哪些呢？ 单元测试(Unit Test)通过模拟输入和预测输出的方式测试独立的函数或者类，为单元编写简单的边缘测试。 集成测试(Integration Test)测试多个模块间的联动是否和期望相同，比如React应用中， props传递是否符合预期，或者使用Mobx状态管理，数据传输是否正确等等。 UI测试也被称为功能测试(Functional Test)关注点不在内部实现方式，而是测试产品在真实使用场景（比如在浏览器）中是否可以达到预想的结果。UI测试可以再特定的环境中模拟用户行为（点击、滚动等）Jest是什么？ Zero configuration testing platformJest is used by Facebook to test all JavaScript code including React applications. One of Jest’s philosophies is to provide an integrated “zero-configuration” experience.引用官方的说法，Jest是一个零配置的测试平台，被Facebook用来测试包括React应用在内的所有JavaScript代码。Jest的理念是提供一套集成的”零配置”体验。Jest内置断言库，可以直接使用expect进行断言，mocha就需要引入Chai或者Jasmine之类的断言库。 Jest的基本配置有两种方式对Jest进行配置：1.package.json中添加jest关键字进行配置。2.新建jest.config.js文件进行配置。 以下列举了在业务场景中，经常会使用到的配置：1234567891011121314151617181920module.exports = &#123; moduleFileExtensions: [ // 模块文件的扩展名，如果希望在引入模块的时候，不指定扩展名，就在这里进行制定. 'js', 'jsx' ], moduleNameMapper: &#123; // 主要用于与webpack的resolve.alias匹配，注意正则写法 '\\.(jpg|jpeg|png|gif|eot|otf|webp|svg|ttf|woff|woff2|mp4|webm|wav|mp3|m4a|aac|oga)$': '&lt;rootDir&gt;/__mocks__/fileMock.js', '.*\\.(css|less|scss)$': '&lt;rootDir&gt;/__mocks__/styleMock.js', '^uiComponents(.*)$': '&lt;rootDir&gt;/src/common/UI$1', '^utils(.*)$': '&lt;rootDir&gt;/src/common/utils$1', '^apis(.*)$': '&lt;rootDir&gt;/src/common/services/api$1', '^components(.*)$': '&lt;rootDir&gt;/src/common/components$1', &#125;, setupFiles: ['&lt;rootDir&gt;/jest.setup.js'], // 运行测试前可运行的脚本(每个测试文件前都会被执行一次),对测试环境进行配置(比如注册enzyme的兼容) testURL: 'https://test.com?empty=&amp;num=0&amp;str=str&amp;cstr=中文&amp;encode=%e4%b8%ad%e6%96%87', // 解决nodejs下没有window.location的问题 snapshotSerializers: ["enzyme-to-json/serializer"], transform: &#123; '^.+\\.js$': 'babel-jest' &#125;&#125; 常用的Jest断言enzymeReact组件测试用例shawllow、mount、render三种方式的区别Mobx测试要想进行Mobx测试，最主要的就是要知道Mobx的装饰器(比如@observable、@observer)是将Mobx的store和react的组件关联起来的。Mobx-react插件提供的@observer装饰器将react组件包裹起来，并将react的render方法重写成了reactiveRender，reactiveRender这个方法会在store里可观察属性发生变化时被调用。因为我们只关注组件，所以我们可以在这个时间节点，使用相关的@observable属性和方法，创建模拟Mobx存储。所以第一步，就是使用observable创建一个模拟的store. 1. 设置12345678910111213141516171819202122232425describe('Capacity History Page', () =&gt; &#123; let store; let commonStore; beforeEach(() =&gt; &#123; //turn off strict mode when testing with mock store // 如果不关闭，则必须使用actions才能修改store的值 useStrict(false); commonStore = observable(&#123; title: '加载中...' &#125;) store = observable(&#123; firstTime: '', historyList: &#123; currentPage: 0, pageCount: 1, pageSize: 20, list: [&#123; demandId: 1 &#125;, &#123; demandId: 2 &#125;], isFetching: false &#125;, getCapacitysFirstTime: jest.fn(), getCapacityHistoryList: jest.fn(), &#125;); &#125;)&#125;) 注意：使用useStrict(false);将Mobx的严格模式关闭。因为在Mobx中，严格模式不允许直接修改store中的属性值，而且要求你必须使用特定的action来修改属性值。如果将useStrict设置成true，在下面演示store更新后，组件渲染会变化的例子中，将不能给store赋值，npm test的时候，会有[mobx] Invariant failed: Since strict-mode is enabled, changing observed observable values outside actions is not allowed. Please wrap the code in an &#39;action&#39; if this change is intended的错误提示。 2. 测试组件是否正在观察store的变化其他]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Jest</tag>
        <tag>enzyme</tag>
        <tag>单元测试</tag>
        <tag>React</tag>
        <tag>Mobx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[聊聊CommonJS、ES6模块、Webpack及Babel]]></title>
    <url>%2Fmodules%2F</url>
    <content type="text"><![CDATA[什么是模块？为什么要模块化？架构师或者比你牛逼的攻城狮搭建好架构后，只知道项目中粘贴代码，不知道何时用require，何时用import，何时用export，何时用module.exports？耐心的看完这篇文章，希望一脸懵逼的你们，能有所获。 模块的由来原始写法将实现类似功能的函数放在一个JS文件中，直接调用。 12345678910// math.jsvar defaultNum1 = 1;var defaultNum2 = 2;function add(num1, num2) &#123; return (num1 || defaultNum1) + (num2 || defaultNum2)&#125;function minus(num1, num2) &#123; return (num1 || defaultNum1) - (num2 || defaultNum2)&#125; 123456789101112// index.html&lt;html&gt; &lt;header&gt; &lt;script src='./utils/math.js'&gt;&lt;/script&gt; &lt;/header&gt; &lt;body&gt; &lt;script&gt; add() minus() &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 以上的写法，其实是直接将add和minus方法直接挂在window对象上，污染了全局变量. 不但无法保证不与其他引入的模块发生变量名冲突(同名时，会发生覆盖，最后引入的起作用).而且模块成员之间看不出直接关系。 对象写法将实现类似功能的函数存放在一个对象(即所谓的模块)中，作为模块的成员变量或方法进行调用。 12345678910var mathModule = &#123; defaultNum1: 1, defaultNum2: 2, add: function(num1, num2) &#123; return (num1 || this.defaultNum1) + (num2 || this.defaultNum2) &#125;, minus: function(num1, num2) &#123; return (num1 || this.defaultNum1) - (num2 || this.defaultNum2) &#125;&#125; 123456// index.html 重复代码就不重复了吧...&lt;script&gt; mathModule.defaultNum1 = 3; mathModule.defaultNum2 = 4; mathModule.add() // 7，mathModule对象的默认状态值被外部修改了&lt;/script&gt; 以上写法，虽然说减少了对全局变量的污染，但是还是存在一些问题，比如向外暴露了模块的所有成员，并且内部状态可以被改写。 自执行函数写法将实现类似功能的函数定义在执行函数中，只暴露需要被外部调用的变量或方法，其实这时候模块的雏形已经出来了。 12345678910111213var mathModule = (function(mod) &#123; var defaultNum1 = 1; var defaultNum2 = 2; var add = function (num1, num2) &#123; return (num1 || defaultNum1) + (num2 || defaultNum2) &#125; var minus = function(num1, num2) &#123; return (num1 || defaultNum1) - (num2 || defaultNum2) &#125; return &#123; add: add &#125;&#125;(otherModule)) 12345// index.html 重复代码就不重复了吧...&lt;script&gt; mathModule.add(); // 3 mathModule.minus(); // undefined&lt;/script&gt; 什么是模块通过以上的几个例子中，大概可以将模块归纳为：一个JavaScript模块就是一个对其他模块暴露一些内部属性/方法的文件。 CommonJS模块 CommonJS是以在浏览器环境之外构建JavaScript生态系统为目标而产生的项目，比如在服务器和桌面环境中. CommonJS实质上就是一个规范，它并不提供默认实现，该规范的主要内容就是，要求一些JavaScript库、框架、环境的模块必须通过module.exports导出对外的变量或接口，通过require()来导入其他模块的输出到当前模块作用域中.CommonJS规范规定，每个模块内部，module变量代表当前模块。这个变量是一个对象，它的exports属性（即module.exports）是对外的接口。加载某个模块，其实是加载该模块的module.exports属性。 12345678910111213141516// math.jsvar defaultNum1 = 1;var defaultNum2 = 2;var add = function(num1, num2) &#123; return (num1 || defaultNum1) + (num2 || defaultNum2)&#125;module.exports.defaultNum1 = defaultNum1;module.exports.defaultNum2 = defaultNum2;module.exports.add = add;// 可简写成module.exports = &#123; defaultNum1: defaultNum1, defaultNum2: defaultNum2, add: add,&#125; require方法用于加载模块 123// index.jsvar mathModule = require('./math.js')var defaultNum1 = mathModule.defaultNum1 // 1 exports与module.exports的区别 module.exports 初始值为一个空对象 {} exports是module.exports的一个引用，一旦exports被重新赋值了，exports与module.exports的相互引用关系就被解绑。 require() 返回的是 module.exports 而不是 exports，所以尽量都用module.exports 导出，然后用require导入。 可能以上的说法有点抽象，举个简单的例子说明 123456789101112131415var module = &#123;&#125;var module.exports = &#123;&#125;;var exports = module.exports; // 指向同一块内存地址module.exports.name = 'test1';console.log(module.exports); // &#123; name: 'test1'&#125;console.log(exports); // &#123; name: 'test1'&#125;exports.name = 'test2';console.log(module.exports); // &#123; name: 'test2'&#125;console.log(exports); // &#123; name: 'test2'&#125;exports = &#123; name: 'test3' &#125;;console.log(module.exports); // &#123; name: 'test2'&#125;console.log(exports); // &#123; name: 'test3'&#125; 总之尽量用module.exports导出。 ES6模块基本用法ES6模块功能主要由两个命令构成：export和import。export命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能。一个文件就是一个模块，外部无法直接使用模块内的变量或者方法，除非使用export对外输出改变量或者方法。 1234567891011121314// 写法一export const defaultNum1 = 1;export const defaultNum2 = 2;export function add(num1, num2) &#123; return (num1 || defaultNum1) + (num2 || defaultNum2)&#125;// 写法二: 推荐这种写法，能够在文件末尾清晰地看出导出了哪些对外接口， 并且可以通过as关键字进行重命名。const defaultNum1 = 1;const defaultNum2 = 2;function add() &#123; return (num1 || defaultNum1) + (num2 || defaultNum2)&#125;export &#123; defaultNum1 as num1, defaultNum2, add &#125; export命令导出的必须是对外的接口，与文件中的变量建立一一对应的关系。所以一定要记得在export的时候 加上{} 123456789101112// math.js// 错误的写法const defalutNum1 = 1;export defalutNum1; // 导出的是变量defalutNum1的值1, 1是一个值，而不是接口// 正确的写法export const defaultNum1 = 1;// 或者const defaultNum1 = 1;export &#123; defaultNum1 &#125;// index.js export default为模块指定默认输出，输出一个叫做default的变量或方法，然后系统允许你为它取任意名字，可以理解为export { default } 12345678910// math.jsconst defaultNum = 1;export default defaultNum;// 等同于export &#123; defaultNum as default &#125;// index.jsimport math from './math'// 等同于，都是引入math.js中使用default导出的变量import &#123; default as math &#125; from 'xxx' 12345678910111213141516// math.js// 正确的写法const defaultNum1 = 1;export default defaultNum1;const defaultNum2 = 2;export default &#123; defaultNum2 &#125;;// 错误的写法export default const defaultNum1 = 1;// index.js// import * as mathModule from './math.js'// const defaultNum1 = mathModule.default; // 结果为1，即math.js使用export default的方式导出的值，export defaut函数也是一样的。// const defaultNum2 = mathModule.default.defaultNum2; // 不能直接获取export default导出的对象 export和export default的区别 export不能导出常量，export default能导出常量 export能直接导出变量表达式，export default不行 一个文件中可以有多个export，但是只能有一个export default 通过export方式导出，在导入时要加{}，export default则不需要，因为export default只能使用一次，只可能唯一对应export default命令。 import命令会被JavaScript引擎静态分析，先于模块内的其他语句执行，在编译时就引入模块代码，而不是在代码运行时加载，所以无法实现条件加载。使用export导出的，在import的时候，需要加上{}, 使用export default则不需要. 1234567891011121314151617181920212223242526// math.js, 一个文件只能有一个export default，注释着用// 非&#123;&#125;导出export const defaultNum1 = 1;const defaultNum2 = 2;export default defaultNum2;// &#123;&#125;导出const defaultNum3 = 3;export &#123; defaultNum3 &#125;const defaultNum4 = 4;export default &#123; defaultNum4 &#125;// index.js，虽然分两次加载，但是它们对应的是同一个math实例, 也就是说，import语句是 Singleton 模式import &#123; defaultNum1, defaultNum3 &#125; from './math'import mathModule from './math'// 合并写法import mathModule, &#123; defaultNum1, defaultNum3 &#125; from './math'// 引用const num1 = defaultNum1;const num2 = mathModule; // 2const num3 = defaultNum3;const num4 = mathModule.defaultNum4 // 4 import mathModule from &#39;./math&#39;与import * as mathModule from &#39;./math&#39;的区别 前者导入的是math.js文件中，以export default导出的内容 后者是将math.js中以export以及default导出的内容合并成了一个mathModule的对象。 12345678910111213141516171819// math.js就是上个例子中的math， 仔细观察如下代码的细微区别// 前者import mathModule from './math'// 引用const defultNum2 = mathModule; // 2，mathModule返回math.js中export default导出的内容const num1 = mathModule.defaultNum1; // undefinedconst num2 = mathModule.defaultNum2; // undefinedconst num3 = mathModule.defaultNum3; // undefinedconst num4 = mathModule.defaultNum4; // 4，mathModule返回math.js中export default导出的内容// 后者import * as mathModule from './math'// 引用const num1 = mathModule.defaultNum1; // 1const num2 = mathModule.default; // 2，mathModule返回math.js中的export default的值被挂在了default的变量上const num3 = mathModule.defaultNum3; // 3const num4 = mathModule.default.defaultNum4; // 4. mathModule返回math.js中的export default的值被挂在了default的变量上const defultNum2 = mathModule.defaultNum2; // undefinedconst defultNum4 = mathModule.defaultNum4; // undefined CommonJS和ES6模块的区别CommonJS模块输出的是一个值的拷贝，而ES6模块输出的是值的引用。CommonJS模块输出的是被输出值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。ES6模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。既然用文字不好表达，那就用代码说话吧~ 12345678910111213141516171819202122// CommonJS// math.jsvar num1 = 1;var add = function() &#123; num1++; console.log('add func:', num1);&#125;module.exports = &#123; num1: num1, add: add&#125;// index.jsvar math = require('./math')console.log('num1 before:', math.num1);math.add();console.log('num1 after:', math.num1);// 控制台打印结果：// num1 before: 1// add func: 2// num1 after: 1 12345678910111213141516171819202122// ES6// math.jsvar num1 = 1;var add = function() &#123; num1++; console.log('add func:', num1);&#125;export &#123; num1, add,&#125;// index.jsimport &#123; num1, add &#125; from './es6Demo2/math'console.log('num1 before:', num1);add();console.log('num1 after:', num1);// 控制台打印结果：// num1 before: 1// add func: 2// num1 after: 2 num1在外部模块调用模块内的方法修改该值后，遵循CommonJS规范的，结果仍然为最初设置的默认值1，验证了CommonJS模块输出的是被输出值的拷贝。而ES6模块编译后，结果输出为2，即调用add方法后更改的值，同样外部调用也会被修改，验证了ES6模块是动态引用. Webpack、Babel在模块化中充当什么角色虽然目前一些主流浏览器支持了部分的es6语法，随着浏览器升级在逐渐地支持，但是就目前来说import和export，几乎所有的浏览器都还不支持，所以需要将es6转换成es5之后，将其运行在浏览器环境下。这时候，Babel就发挥了它的作用。Babel · The compiler for next generation JavaScript(下一代Javascript的编译器) 12345678910111213141516// ES6语法import &#123; defaultNum1 &#125; from './es6Modules'console.log('defaultNum1:', defaultNum1);export const result = 100;// Babel编译后'use strict';Object.defineProperty(exports, "__esModule", &#123; value: true&#125;);exports.result = undefined;var _es6Modules = require('./es6Modules');console.log('defaultNum1:', _es6Modules.defaultNum1);var result = exports.result = 100;` 以上ES6通过Babel转换成ES5代码之后，将其通过标签引入运行在Chrome浏览器环境下，会发现报错’exports is not defined’。这是因为通过Babel转换的代码遵循的是CommonJS规范，而这个规范，浏览器并不能识别，所以需要将其运行在CommonJS环境中，比如nodejs、webpack、browserify等， 总结：E6模块要想在浏览器环境下正常运行，需要经过es6-&gt;es5(commonJS规范)-&gt;浏览器可执行代码 Webpack本身是遵循CommonJS规范的，从它的配置文件webpack.config.js（module.exports = {}）中可以看出来。它通过各种loader，它可以将任何形式的资源都视作模块，比如commonjs模块、AMD模块、ES6模块、CSS、图片、SASS、JSON等。 webpack的工作方式是：把你的项目当做一个整体，通过一个给定的主文件（比如index.html），webpack将从这个文件开始找到你项目的所有依赖文件，使用loaders处理他们，并且最终打包为浏览器可识别的静态资源。babel-loader：完成了用es6写法直接生成浏览器可识别的代码，而不用单独用babel指令生成代码再转换。 接下来看一下webpack是如何将原来ES6模块代码转换成可以被浏览器识别的资源的。 12345678910&lt;html&gt; &lt;head&gt; &lt;title&gt;前端模块化&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;Demo&lt;/div&gt; &lt;!--引入webpack打包后的文件--&gt; &lt;script src="./bin/bundle.js"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 1234567891011&#123; "name": "demo", "version": "1.0.0", "devDependencies": &#123; "babel-core": "^6.26.3", "babel-loader": "^7.1.5", "babel-preset-es2015": "^6.24.1", "webpack": "^4.22.0" ... &#125;,&#125; 1234567891011121314// webpack.config.jsmodule.exports = &#123; entry:__dirname + '/src/app.js', ... module: &#123; rules: [ &#123; test: /\.js$/, // 匹配打包文件后缀名的正则 exclude: /(node_modules|bower_components)/, // 这些文件夹不用打包 loader: 'babel-loader' &#125; ] &#125;&#125; 123// src/app.jsimport &#123; printColors &#125; from './js/printColor';printColors(); 1234567// src/js/printColor.jsvar colors = ['red', 'green', 'yello', 'black', 'other'];export const printColors = () =&gt; &#123; for (let color of colors) &#123; document.write('&lt;p&gt;' + color +'&lt;/p&gt;') &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374// 编译后的bundle.js文件(function(modules) &#123; // webpack已注册的模块 var installedModules = &#123;&#125;; // __webpack_require__ Webpack管理模块的核心 function __webpack_require__(moduleId) &#123; // 检查模块是否已被缓存，如果是，则直接返回模块的exports属性 if(installedModules[moduleId]) &#123; return installedModules[moduleId].exports; &#125; // 如果模块没有被缓存过，则创建一个新的模块，并将其存入缓存 var module = installedModules[moduleId] = &#123; i: moduleId, // 模块Id，import XXX from moduleId l: false, // loaded的缩写，表示模块是否已注册 exports: &#123;&#125; // 模块的输出，默认为&#123;&#125;, 后续调用模块方法是作为参数传入 &#125;; /** * 执行模块的方法 * modules[moduleId]: 模块的立即执行函数 * module: 包含模块ID, 是否已注册，exports空对象的初始化参数 * module.exports: &#123;&#125; * __webpack_require__: 函数本身，方便在模块中调用其他模块 */ modules[moduleId].call(module.exports, module, module.exports, __webpack_require__); // 设为true，表示已注册 module.l = true; // 输出module.exports属性 return module.exports; &#125; // 在 __webpack_require__ 这个函数上绑定一系列属性 ... // 调用__webpack_require__函数，开始加载模块，返回exports return __webpack_require__(__webpack_require__.s = "./src/app.js");&#125;)(&#123; "./src/app.js": ( function(module, exports, __webpack_require__) &#123; "use strict"; // 调用__webpack_require__函数，加载printColor模块，返回exports，由于在该模块中定义了printColors方法，并挂载在了module.exports上，所以可以进行调用 var _printColor = __webpack_require__(/*! ./js/webpackDemo/printColor */ "./src/js/webpackDemo/printColor.js"); (0, _printColor.printColors)(); &#125;), "./src/js/webpackDemo/printColor.js": ( function(module, exports, __webpack_require__) &#123; "use strict"; Object.defineProperty(exports, "__esModule", &#123; value: true &#125;); var colors = ['red', 'green', 'yello', 'black', 'other']; const printColors = exports.printColors = () =&gt; &#123; var _iteratorNormalCompletion = true; var _didIteratorError = false; var _iteratorError = undefined; try &#123; for (var _iterator = colors[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) &#123; let color = _step.value; document.write('&lt;p&gt;' + color + '&lt;/p&gt;'); &#125; &#125; catch (err) &#123; _didIteratorError = true; _iteratorError = err; &#125; finally &#123; try &#123; if (!_iteratorNormalCompletion &amp;&amp; _iterator.return) &#123; _iterator.return(); &#125; &#125; finally &#123; if (_didIteratorError) &#123; throw _iteratorError; &#125; &#125; &#125; &#125;; &#125;) &#125;); 简化以上代码，webpack编译出了一个自执行函数，该自执行函数做的事情可归纳为以下几个小点： 参数modules：以模块名或者路径为key，自执行函数为value组成的一个object，类似于{‘./src/app.js’: (function(){}), ‘./src/js/webpackDemo/printColor.js’: (function(){})}. 定义一个对象 installModlues 来保存 Webpack 已注册的模块. 定义一个函数 __webpack_require__ 来实现的模块的加载. 在 __webpack_require__ 这个函数上绑定一些属性，上面代码中没有做详细介绍，可以自己起个webpack项目，编译出来看下。 调用__webpack_require__函数，开始加载模块，这个例子中调用的是’./src/app.js’模块。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>CommonJS</tag>
        <tag>ES6模块</tag>
        <tag>Webpack</tag>
        <tag>Babel</tag>
      </tags>
  </entry>
</search>
