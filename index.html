<!DOCTYPE html>












  


<html class="theme-next mist use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
































<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.6.0" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.6.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.6.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.6.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.6.0" color="#222">









<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '6.6.0',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="一枚文科毕业，工作5+年的程序媛👨‍💻。">
<meta name="keywords" content="前端">
<meta property="og:type" content="website">
<meta property="og:title" content="苏三 • 博客">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="苏三 • 博客">
<meta property="og:description" content="一枚文科毕业，工作5+年的程序媛👨‍💻。">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="苏三 • 博客">
<meta name="twitter:description" content="一枚文科毕业，工作5+年的程序媛👨‍💻。">






  <link rel="canonical" href="http://yoursite.com/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>苏三 • 博客</title>
  












  <noscript>
  <style>
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion .logo-line-before i { left: initial; }
    .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">苏三 • 博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home menu-item-active">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
        </li>
      
    </ul>
  

  
    

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/graphql-client/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="苏三">
      <meta itemprop="description" content="一枚文科毕业，工作5+年的程序媛👨‍💻。">
      <meta itemprop="image" content="/images/common/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="苏三 • 博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/graphql-client/" class="post-title-link" itemprop="url">GraphQL-API查询篇</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-05-27 14:45:48" itemprop="dateCreated datePublished" datetime="2019-05-27T14:45:48+08:00">2019-05-27</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-06-03 11:02:10" itemprop="dateModified" datetime="2019-06-03T11:02:10+08:00">2019-06-03</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="GraphQL是什么？"><a href="#GraphQL是什么？" class="headerlink" title="GraphQL是什么？"></a>GraphQL是什么？</h4><blockquote>
<p>GraphQL is a query language for your API, and a server-side runtime for executing queries by using a type system you define for your data. GraphQL isn’t tied to any specific database or storage engine and is instead backed by your existing code and data.</p>
</blockquote>
<p>个人释义：GraphQL是一种API查询语言，并且是服务端运行时使用类型系统定义数据后执行查询的一种方式。它不依赖于任何特殊的数据库或者存储引擎，而是依赖于你现有的代码及数据。</p>
<p>由<a href="https://graphql.org" target="_blank" rel="noopener">官网</a>的解释，可以看出GraphQL是包含客户端和服务端两部分的。<br>在看完这个官网文档之后，其实我更愿意认为GraphQL是一种标准，而与标准相对的便是实现(如graphql-js)。就像 EcmaScript 与 JavaScript 的关系。接下来，将按照<a href="https://graphql.org/graphql-js/" target="_blank" rel="noopener">graphql-js</a>展开。</p>
<p>先来看一个例子来感受下<br><img src="/images/graphql/demo1.gif" width="495" height="369"></p>
<p>这是我本地启了一个服务器，使用<a href="https://github.com/graphql/graphiql" target="_blank" rel="noopener">graphiql</a>作为客户端，发起请求的过程。<br>左边为请求，右边为返回值，在服务端不做任何代码调整并且不作任何逻辑判断的前提下，可以看到client端若只请求一个id字段，则Server端只返回一个id，这就是GraphQL的强大之处。</p>
<p>可能又有人会问了，那我如果要传递参数咋办？这个演示的只是从服务端获取数据，那我要新增或者修改数据咋办？不要急，接下来先来学习一下client端的基本语法。</p>
<h5 id="字段"><a href="#字段" class="headerlink" title="字段"></a>字段</h5><h5 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h5><blockquote>
<p>In a system like REST, you can only pass a single set of arguments - the query parameters and URL segments in your request. But in GraphQL, every field and nested object can get its own set of arguments, making GraphQL a complete replacement for making multiple API fetches.</p>
</blockquote>
<p><img src="/images/graphql/demo2.gif" width="495" height="369"></p>
<p>字段后面跟着<code>()</code>里的就是查询携带的参数，可以看到不仅仅只有最外层可以携带参数，字段内嵌套的同样也可以携带参数，只要在服务端有相应的resolve function来处理这个字段。也就是官网提到的<code>every field and nested object can get its own set of arguments, making GraphQL a complete replacement for making multiple API fetches</code></p>
<h5 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h5><p><img src="/images/graphql/demo3.gif" width="495" height="369"></p>
<p>为了代码更语义化，我们为了区分post和comment的id，给它们分别设置别名，postID、commentId，当然这只是一个例子，GraphQL中的每一个字段和嵌套的对象都可以有一个别名。</p>
<h5 id="片段"><a href="#片段" class="headerlink" title="片段"></a>片段</h5><p>设想一下，一个页面包含两个tab，一个tab是生活类文章，一个tab是学习类文章(当然例子可能不太恰当，只是为了引出下面跟片段相关的例子)，这时候两个列表返回值的数据结构是一模一样的，或者只有细微差异，但是都是Post类型，按照之前的写法，可能就需要写成<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">query &#123;</span><br><span class="line">  lifePosts: posts(type: <span class="number">1</span>) &#123;</span><br><span class="line">    id</span><br><span class="line">    type</span><br><span class="line">    title</span><br><span class="line">  &#125;</span><br><span class="line">  learningPosts: posts(type: <span class="number">2</span>) &#123;</span><br><span class="line">    id</span><br><span class="line">    type</span><br><span class="line">    title</span><br><span class="line">    author</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但是有了片段之后，不需要重复定义返回的数据结构了，用例子说话：<br><img src="/images/graphql/demo4.gif" width="495" height="369"></p>
<p>需要注意的是<code>fragment postFields on Post</code>其中on后面跟的Post是在服务端定义的文章类型，这句代码可以理解为”根据Post类型定义一个postFields片段”，所以<code>Post</code>字段一定包含<code>postFields</code>字段，它们是包含的关系。<br>那片段能不能使用变量呢？答案当然是可以的，结合上文参数例子的基础上进行调整，来再看个例子<br><img src="/images/graphql/demo5.gif" width="495" height="369"></p>
<p>例子中，<code>$top: Int = 3</code>主要是为了调试方便，没有从外部传入变量，参数直接使用的默认值。</p>
<h5 id="操作类型及操作名称"><a href="#操作类型及操作名称" class="headerlink" title="操作类型及操作名称"></a>操作类型及操作名称</h5><blockquote>
<p>The operation type is either query, mutation, or subscription and describes what type of operation you’re intending to do. The operation type is required unless you’re using the query shorthand syntax, in which case you can’t supply a name or variable definitions for your operation.</p>
</blockquote>
<p>query：顾名思义就是查询语句，上文中的所有语句都属于query操作。<br>mutation：插入和更新操作，后面会介绍<br>subscription：订阅，后面也会介绍</p>
<p>仔细看gif图的盆友应该已经注意到了，demo1、demo2既没有使用query操作类型 也没有操作名称，demo3、demo4加了个query，demo5开始加了个名称<code>postList</code>, 对于不携带参数的API查询，query操作符及操作名称是可以省略。</p>
<h5 id="变量定义及默认变量-variables"><a href="#变量定义及默认变量-variables" class="headerlink" title="变量定义及默认变量(variables)"></a>变量定义及默认变量(variables)</h5><p>之前的所有例子，要么将参数写死在query语句中，要么就是外部没有传入变量使用默认值查询，那么怎么从外部传入变量，提高灵活性呢？<br>由于graphiql的局限性，我们采用另一种方式模拟graphql客户端API查询，直接调用fetch(至于为什么用fetch，有兴趣的同学可以看下<a href="https://github.com/graphql/express-graphql" target="_blank" rel="noopener">express-graphql源码</a>的renderGraphiQL文件)方法，代码如下:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> query = <span class="string">`</span></span><br><span class="line"><span class="string">fragment postFields on Post &#123;</span></span><br><span class="line"><span class="string">  id</span></span><br><span class="line"><span class="string">  title</span></span><br><span class="line"><span class="string">  comments(top: $first) &#123;           //  为了区分，将原来的变量$top为$first</span></span><br><span class="line"><span class="string">    user</span></span><br><span class="line"><span class="string">    comment</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">query postList($first: Int = 1)&#123;    //  为了区分，将原来的变量$top为$first</span></span><br><span class="line"><span class="string">  lifePosts: posts(type: 1) &#123;</span></span><br><span class="line"><span class="string">    ...postFields</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">  learningPosts: posts(type: 2) &#123;</span></span><br><span class="line"><span class="string">    ...postFields</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;`</span></span><br><span class="line">fetch(<span class="string">'/graphql'</span>, &#123;</span><br><span class="line">  method: <span class="string">'POST'</span>,</span><br><span class="line">  headers: &#123;</span><br><span class="line">    <span class="string">'Content-Type'</span>: <span class="string">'application/json'</span>,</span><br><span class="line">    <span class="string">'Accept'</span>: <span class="string">'application/json'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  body: <span class="built_in">JSON</span>.stringify(&#123;query, <span class="attr">variables</span>: &#123; <span class="attr">first</span>: <span class="number">3</span> &#125;&#125;)    <span class="comment">// variables参数传入</span></span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> response.json()</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'data:'</span>, <span class="built_in">JSON</span>.stringify(data))</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>可以看到参数first通过variables字段传递，虽然同样也是设置了变量默认值<code>$first: Int = 1</code>，但是最终的查询结果去前3条comments。</p>
<h5 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h5><p>GraphQL 的核心规范包含两个指令，其必须被任何规范兼容的 GraphQL 服务器实现所支持：</p>
<ul>
<li>@include(if: Boolean) 仅在参数为 true 时，包含此字段。</li>
<li>@skip(if: Boolean) 如果参数为 true，跳过此字段，顾名思义就是与@include相反的操作结果。</li>
</ul>
<p><img src="/images/graphql/demo6.gif" width="495" height="369"></p>
<p>由此可以看出，查询API可以通过一个变量来增减返回字段，当然官网也说了在服务端可以自定义指令，但是并未明确如何定义，有兴趣的可以看下<a href="">apollo-server源码</a>，印象中有一个<code>client</code>指令，这里暂时不涉及。</p>
<h5 id="变更Mutation"><a href="#变更Mutation" class="headerlink" title="变更Mutation"></a>变更Mutation</h5><p>之前讨论的都是怎么查询操作，接下来我来说说如何增加、修改、删除操作？</p>
<blockquote>
<p>In REST, any request might end up causing some side-effects on the server, but by convention it’s suggested that one doesn’t use GET requests to modify data. GraphQL is similar - technically any query could be implemented to cause a data write. However, it’s useful to establish a convention that any operations that cause writes should be sent explicitly via a mutation.</p>
</blockquote>
<p>这句话什么意思，就是说GraphQL也是可以用Query的方法修改数据，但是使用mutation来更新服务端数据是一种约定。</p>
<p>先来看下使用最简单的query插入数据<br><img src="/images/graphql/demo7.gif" width="495" height="369"></p>
<p>对graphql有一点了解的人，可能知道有个graphql Input类型，并且一般都是跟mutation一起被提及，我们可以再来看一下query和input类型结合使用是否可行？</p>
<p><img src="/images/graphql/demo8.gif" width="495" height="369"><br>可以看出，修改服务端为接收Input类型参数后，使用query方法插入数据，服务端能正确接收到参数，并且成功插入数据，由此证实了使用query是可以修改服务端数据的，但是规范毕竟是规范，没有规矩不成方圆，还是按照官网使用mutation的方式对服务进行增、删、改操作。在服务端增加Mutation相应的入口方法。</p>
<p><img src="/images/graphql/demo9.gif" width="495" height="369"></p>
<p>虽然上述几个例子证明了query和mutation都能修改服务端数据，操作方式看似业务差异，但是官网更有云:</p>
<blockquote>
<p>A mutation can contain multiple fields, just like a query. There’s one important distinction between queries and mutations, other than the name: While query fields are executed in parallel, mutation fields run in series, one after the other. This means that if we send two incrementCredits mutations in one request, the first is guaranteed to finish before the second begins, ensuring that we don’t end up with a race condition with ourselves.</p>
</blockquote>
<p>他们不仅仅只是名字上的区别，执行过程才是重点，query方法是并行执行的，而mutation是线性执行，一个执行完之后才会执行下一个。就是说如果一个query或者mutation中包含多个方法，一个是并行的，一个是串行的。</p>
<h5 id="内联片段"><a href="#内联片段" class="headerlink" title="内联片段"></a>内联片段</h5><p>这个需要结合服务端的接口类型或联合类型结合学习，这里暂不赘述。</p>
<h5 id="元字段-typename"><a href="#元字段-typename" class="headerlink" title="元字段(__typename)"></a>元字段(__typename)</h5><p>这个在服务端返回值包含接口类型或联合类型时，区分是什么类型的数据非常有用，也将会在Schame中详细介绍。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/graphql1.bak/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="苏三">
      <meta itemprop="description" content="一枚文科毕业，工作5+年的程序媛👨‍💻。">
      <meta itemprop="image" content="/images/common/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="苏三 • 博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/graphql1.bak/" class="post-title-link" itemprop="url">GraphQL</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-05-27 14:45:48" itemprop="dateCreated datePublished" datetime="2019-05-27T14:45:48+08:00">2019-05-27</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-05-31 10:59:31" itemprop="dateModified" datetime="2019-05-31T10:59:31+08:00">2019-05-31</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>GraphQL可以理解为是一种标准，而与标准相对的便是实现。就像 EcmaScript 与 JavaScript 的关系。</p>
<p>给你的API发送一个GraphQL查询，可以不多不少的获取你想要的。</p>
<p>GraphQL Servers<br>服务端 express-graphql | apollo-server</p>
<p>GraphQL Clients<br>appolo-client：一款对React、React Native、Angular 2或者Javascript都非常友好<br>当然Andorid(Java) iOS(Swift / Objective-C)都有相应的实现</p>
<p>awesome-graphql：一个维护GraphQL的出色社区</p>
<p>GraphQL is a query language for your API, and a server-side runtime for executing queries by using a type system you define for your data.<br>GraphQL是一种API查询语言，和服务端运行时，类型定义系统执行查询。</p>
<h4 id="Query"><a href="#Query" class="headerlink" title="Query"></a>Query</h4><h5 id="字段"><a href="#字段" class="headerlink" title="字段"></a>字段</h5><h5 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h5><p>嵌套对象，是否可以加参数，嵌套的参数怎么查询？例如：<br>query student(studentId: 1) {<br>  name<br>  class (classId: 3) {<br>    index<br>  }<br>}</p>
<h5 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h5><h5 id="片段"><a href="#片段" class="headerlink" title="片段"></a>片段</h5><p>GraphQL查询包含可复用单元，比如任务列表，包含进行中、已完结，类似于<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fragment taskListFragment on Character &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">query tasks &#123;</span><br><span class="line">  processingTaskList &#123;</span><br><span class="line">    ...taskListFragment</span><br><span class="line">  &#125;</span><br><span class="line">  finishTaskList &#123;</span><br><span class="line">    ...taskListFragment</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>操作类型包括query(简单的查询可以省略)、mutation和subscription</p>
<h5 id="操作名称"><a href="#操作名称" class="headerlink" title="操作名称"></a>操作名称</h5><h5 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h5><h5 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h5><p>@include(if: Boolean) 仅在参数为 true 时，包含此字段。<br>@skip(if: Boolean) 如果参数为 true，跳过此字段。<br>例如，以下的例子，只有在withFriends为true时，才会返回friends字段<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">query Hero($episode: Episode, <span class="attr">$withFriends</span>: <span class="built_in">Boolean</span>!) &#123;</span><br><span class="line">  hero(episode: $episode) &#123;</span><br><span class="line">    name</span><br><span class="line">    friends @include(<span class="keyword">if</span>: $withFriends) &#123;</span><br><span class="line">      name</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="Mutation"><a href="#Mutation" class="headerlink" title="Mutation"></a>Mutation</h4><h5 id="InputType"><a href="#InputType" class="headerlink" title="InputType"></a>InputType</h5><h5 id="内联片段-定义接口interface和联合类型String-Number"><a href="#内联片段-定义接口interface和联合类型String-Number" class="headerlink" title="内联片段(定义接口interface和联合类型String | Number)"></a>内联片段(定义接口interface和联合类型String | Number)</h5><p>例子：<br>返回值是根据角色返回不同字段，则可以根据内联片段来区分。</p>
<h5 id="typename"><a href="#typename" class="headerlink" title="__typename"></a>__typename</h5><h4 id="Schema和类型"><a href="#Schema和类型" class="headerlink" title="Schema和类型"></a>Schema和类型</h4><p>GraphQL 服务可以用任何语言编写，因为我们并不依赖于任何特定语言的句法句式（譬如 JavaScript）来与 GraphQL schema 沟通，我们定义了自己的简单语言，称之为 “GraphQL schema language” —— 它和 GraphQL 的查询语言很相似，让我们能够和 GraphQL schema 之间可以无语言差异地沟通。</p>
<p>两个特殊类型Query和Mutation，GraphQL Clients使用query或mutation操作查询或更改，针对这两个入口，GraphQL Servers同样有两种类型来定义GraphQL入口。</p>
<h5 id="标量类型"><a href="#标量类型" class="headerlink" title="标量类型"></a>标量类型</h5><p>Int：有符号 32 位整数。<br>Float：有符号双精度浮点值。<br>String：UTF‐8 字符序列。<br>Boolean：true 或者 false。<br>ID：ID 标量类型表示一个唯一标识符，通常用以重新获取对象或者作为缓存中的键。ID 类型使用和 String 一样的方式序列化；然而将其定义为 ID 意味着并不需要人类可读型。</p>
<h5 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h5><p>自定义标量类型<br>枚举</p>
<h6 id="列表和非空"><a href="#列表和非空" class="headerlink" title="列表和非空"></a>列表和非空</h6><p>[String]!和[String]!<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// myField: [String!]</span></span><br><span class="line">myField: <span class="literal">null</span>   <span class="comment">// success</span></span><br><span class="line">myField: []     <span class="comment">// success</span></span><br><span class="line">myField: [<span class="string">'a'</span>, <span class="string">'b'</span>] <span class="comment">//  success</span></span><br><span class="line">myField: [<span class="string">'a'</span>, <span class="literal">null</span>, <span class="string">'b'</span>] <span class="comment">// failed</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// myField: [String]!</span></span><br><span class="line">myField: <span class="literal">null</span>   <span class="comment">// failed</span></span><br><span class="line">myField: []     <span class="comment">// true</span></span><br><span class="line">myField: [<span class="string">'a'</span>, <span class="string">'b'</span>] <span class="comment">//  true</span></span><br><span class="line">myField: [<span class="string">'a'</span>, <span class="literal">null</span>, <span class="string">'b'</span>] <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<h6 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h6><p>指定类型之间的共同字段，每一个实现该接口的类型，必须包含该接口中存在的字段，从而实现该接口。</p>
<h6 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h6><p>String | Number</p>
<h6 id="输入类型-InputTypes"><a href="#输入类型-InputTypes" class="headerlink" title="输入类型(InputTypes)"></a>输入类型(InputTypes)</h6><p>通过使用类型系统，你可以预判一个查询是否有效。这让服务器和客户端可以在无效查询创建时就有效地通知开发者，而不用依赖运行时检查。</p>
<h4 id="GraphQL执行过程"><a href="#GraphQL执行过程" class="headerlink" title="GraphQL执行过程"></a>GraphQL执行过程</h4><p>您可以将 GraphQL 查询中的每个字段视为返回子类型的父类型函数或方法。事实上，这正是 GraphQL 的工作原理。每个类型的每个字段都由一个 resolver 函数支持，该函数由 GraphQL 服务器开发人员提供。当一个字段被执行时，相应的 resolver 被调用以产生下一个值。</p>
<ol>
<li>类型系统校验</li>
<li>解析函数解析</li>
<li>键值对映射，返回json</li>
</ol>
<p>如果字段产生标量值，例如字符串或数字，则执行完成。如果一个字段产生一个对象，则该查询将继续执行该对象对应字段的解析器，直到生成标量值。GraphQL 查询始终以标量值结束。</p>
<h5 id="Resolver"><a href="#Resolver" class="headerlink" title="Resolver"></a>Resolver</h5><p>每一个 GraphQL 服务端应用的顶层，必有一个类型代表着所有进入 GraphQL API 可能的入口点，我们将它称之为 Root 类型或 Query 类型。</p>
<p>优点</p>
<p>API版本控制我觉得这个优点有点牵强，他的解释是可以在原接口添加字段，按理说，原来的RESTful直接添加也没毛病。<br>后来思考了一下，还是有区别的，RESTful增加字段，老版本接口也会新增这个字段，而GraphQL不会。</p>
<h4 id="deprecated有待研究"><a href="#deprecated有待研究" class="headerlink" title="@deprecated有待研究"></a>@deprecated有待研究</h4><p>introspection 内省？</p>
<p>缓存实现原理</p>
<p>subscription订阅</p>
<p>缺点<br>N+1问题<br>DataLoader: 可以将多个数据库请求合并成一个，也可以缓存数据库查询结果</p>
<p>项目中现有的实现方式是不是没有将GraphQL的特性发挥出来？</p>
<ol>
<li>项目中仍然使用一个功能写一个对应的API接口，与RESTful类似，而不是采用一个接口，让客户端选择查询。 <a href="https://draveness.me/graphql-microservice" target="_blank" rel="noopener">集中式vs分布式</a></li>
</ol>
<p>GraphQL中，我们会有这样一个约定，Query和与之对应的Resolver是同名的，这样在GraphQL才能把它们对应起来，举个例子，比如关于articles(): [Article!]!这个Query, 它的Resolver的名字必然叫做articles。</p>
<p>Resolver内部实现对于GraphQL完全是黑盒状态</p>
<p>GraphQL查询语言-GraphQL Clients<br>GraphQL类型语言-GraphQL Servers</p>
<p>Query<br>Mutation<br>Subscription</p>
<p><a href="https://blog.apollographql.com/graphql-explained-5844742f195e" target="_blank" rel="noopener">GraphQL是怎么将一个Query转换成Response的？</a></p>
<ol>
<li><p>GraphQL queries</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  query getAuthor(id: <span class="number">5</span>)&#123;</span><br><span class="line">   name</span><br><span class="line">   posts &#123;</span><br><span class="line">     title</span><br><span class="line">     author &#123;</span><br><span class="line">       name</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Schema and resolve functions<br>每个GraphQL服务器都有两个关键的部分来决定该如何工作，那就是Schema和resolve functions。<br>Schema：定义了GraphQL服务器的数据模型，即client可以从这个GraphQL服务器获取到哪些数据及数据结构是什么样的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">type Author &#123;</span><br><span class="line">  id: Int</span><br><span class="line">  name: <span class="built_in">String</span></span><br><span class="line">  posts: [Post]</span><br><span class="line">&#125;</span><br><span class="line">type Post &#123;</span><br><span class="line">  id: Int</span><br><span class="line">  title: <span class="built_in">String</span></span><br><span class="line">  text: <span class="built_in">String</span></span><br><span class="line">  author: Author</span><br><span class="line">&#125;</span><br><span class="line">type Query &#123;</span><br><span class="line">  getAuthor(id: Int): Author</span><br><span class="line">  getPostsByTitle(titleContains: <span class="built_in">String</span>): [Post]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>正如上面的例子，包含三种类型，Query、Author、Post，其中Query标志着查询的入口，每个查询都需要从Query的字段开始，比如getAuthor、getPostsByTitle。通过Author可以查询某个作者拥有的文章列表，当然也可以通过某篇文章查询文章作者信息，这就是Schema的作用：(1) client端可以获取哪些字段 (2) 描述字段间的关系</p>
<p>Resolve Functions<br>解决参数是什么？根据参数怎么获取所需数据？GraphQL Resolve Functions可以包含任意代码,这意味着GraphQL服务器可以与任何类型的后端交互。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">getAuthor(_, args)&#123;</span><br><span class="line">  <span class="keyword">return</span> sql.raw(<span class="string">'SELECT * FROM authors WHERE id = %s'</span>, args.id);</span><br><span class="line">&#125;</span><br><span class="line">posts(author)&#123;</span><br><span class="line">  <span class="keyword">return</span> request(<span class="string">`https://api.blog.io/by_author/<span class="subst">$&#123;author.id&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="3">
<li>GraphQL execution(以GraphQL-JS为例，基本上所有的GraphQL服务端实现都遵循以下步骤)<br>响应步骤：<br>（1）解析：服务器首先解析查询语句，将其转换成抽象语法树，如果有任何语法错误，服务器则会停止运行，并将错误返回给client端<br>（2）验证：验证查询语句，参数及返回值字段是否存在在schema中(比如getAuthor是否是Query的一个字段，getAuthor是否接受一个名为id的参数字段，getAuthor是否有返回name、posts字段等)，GraphQL-JS在真正执行之前，会自动所有完成验证操作。<br>（3）执行：GraphQL从query的顶部开始执行。</li>
</ol>
<p>  GraphQL拥有自己的类型语言，用来定义Schema，称之为Schema Definition Language(SDL)。</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type User &#123;</span><br><span class="line">  id: ID!</span><br><span class="line">  name: <span class="built_in">String</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  User类型只是简单的定义了应用中user模型的数据结构，如果想要获取id或name值，就需要将其挂载在Query下。<br>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type Query &#123;</span><br><span class="line">  user(id: ID!): User</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>  定义入口是GraphQL能正确执行的前提条件，只有在Query类型下定义了正确的Schema，以下查询语句才能执行<br>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">query &#123;</span><br><span class="line">  user(id: <span class="number">3</span>) &#123;</span><br><span class="line">    id</span><br><span class="line">    name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> 注：Query、Mutation、Subscription类型的定义是调用GraphQL API入口</p>
<p>GraphQL engine(比如GraphQL.js)<br>GraphQL.js是GraphQL的实现，并为其他库(比如graphql-tools、graphene-js)提供了基石。所有库的实现都是围绕GraphQLSchema对象的两个组成部分：模型声明Schema Definition和具体实现resolver functions</p>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Graph-js实现</span></span><br><span class="line"><span class="keyword">const</span> UserType = <span class="keyword">new</span> GraphQLObjectType(&#123;</span><br><span class="line">  name: <span class="string">'User'</span>,</span><br><span class="line">  fields: &#123;</span><br><span class="line">    id: &#123; <span class="attr">type</span>: GraphQLID &#125;,</span><br><span class="line">    name: &#123; <span class="attr">type</span>: GraphQLString &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> schema = <span class="keyword">new</span> GraphQLSchema(&#123;</span><br><span class="line">  query: <span class="keyword">new</span> GraphQLObjectType(&#123;</span><br><span class="line">    name: <span class="string">'Query'</span>,</span><br><span class="line">    fields: &#123;</span><br><span class="line">      user: &#123;</span><br><span class="line">        type: UserType,</span><br><span class="line">        args: &#123;</span><br><span class="line">          id: &#123; <span class="attr">type</span>: GraphQLID &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * root: 前一个resolver function调用的返回结果，初始值为null</span></span><br><span class="line"><span class="comment">         * args: 请求参数</span></span><br><span class="line"><span class="comment">         * context: resolver上下文</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        resolve: <span class="function">(<span class="params">root, args, context, info</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">const</span> &#123; id &#125; = args <span class="comment">// the `id` argument for this field is declared above</span></span><br><span class="line">          <span class="keyword">return</span> fetchUserById(id) <span class="comment">// hit the database</span></span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;),</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>Since a GraphQL query at its essence is just a collection of fields, all a GraphQL server actually needs to do in order to gather the requested data is invoke all the resolver functions for the fields specified in the query.<br>Schema，每个字段都有一个Resolver function，</p>
<p><code>graphql-tools</code>：the biggest benefit of using graphql-tools is its nice API for connecting your declarative schema with resolvers!</p>
<p>Resolver function方法剖析</p>
<p>GraphQL查询及返回 是怎么在网络间传输的？</p>
<p>由于Express解决了如何处理http请求，而graphql.js解决了如何查询的功能？现在就是怎么将其结合起来的问题？这时候就出现了express-graphql和apollo-server库，它们实际上都只是express的中间件。</p>
<p>express-graphql: 主要包含两部分功能<br>(1) 保证包含在POST请求体中的GraphQL query (或者mutation)，可以被GraphQL.js执行，所以,它需要解析查询并将其转发给graphql函数执行。<br>(2) 将执行的结果附加到响应对象,因此它可以返回给客户端。</p>
<p><a href="https://github.com/graphql/express-graphql/blob/master/src/index.js" target="_blank" rel="noopener">源码解读</a></p>
<p>apollo-server：其实跟express-graph类似，但是它集成了更多的框架，比如express、koa、hapi等，想要使用的话，只要安装相应的包，比如apollo-server-express.</p>
<p>GraphQL服务通过express-graphql起来之后可以使用任意的库发起携带query(variables)参数的POST请求. query实际上就是一个字符串，可以使用<a href="https://github.com/apollographql/graphql-tag" target="_blank" rel="noopener">graphql-tag</a>模板库，具备更多的功能。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">fetch(<span class="string">'/graphql'</span>, &#123;</span><br><span class="line">  method: <span class="string">'POST'</span>,</span><br><span class="line">  headers: &#123;</span><br><span class="line">    <span class="string">'Content-Type'</span>: <span class="string">'application/json'</span>,</span><br><span class="line">    <span class="string">'Accept'</span>: <span class="string">'application/json'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  body: <span class="built_in">JSON</span>.stringify(&#123;<span class="attr">query</span>: <span class="string">"&#123; hello &#125;"</span>&#125;)</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> response.json()</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'data:'</span>, data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>GraphQL是标准<br>GraphQL.js是底层实现<br>express-graphql是网关层，<br>apollo-server同样是网关层</p>
<p>现有的GraphQL服务端，基本上都是依赖于Graphql.js的，所以要学习建议从<a href="https://graphql.org/graphql-js/" target="_blank" rel="noopener">这里</a>入门</p>
<h4 id="Object-types"><a href="#Object-types" class="headerlink" title="Object types"></a>Object types</h4><p>This way of defining object types often provides advantages over a traditional REST API. Instead of doing one API request to get basic information about an object, and then multiple subsequent API requests to find out more information about that object, you can get all of that information in one API request. That saves bandwidth, makes your app run faster, and simplifies your client-side logic.</p>
<p>GraphQL 这种方式能够将原有 RESTful 风格时的多次请求聚合成一次请求，不仅能够减少多次请求带来的延迟，还能够降低服务器压力，加快前端的渲染速度。 不太理解？<br>设想一种场景：<br>查询一个文章的信息，comments需要去调另一个服务的。<br>移动端需要的数据结构类似于<br>{<br>  post(id: 3500401) {<br>    id,<br>    title,<br>    stars<br>  }<br>}</p>
<p>web端需要的数据结构类似于<br>{<br>  post(id: 3500401) {<br>    title,<br>    comments<br>  }<br>}</p>
<p>对比一下，我们发现只是少了两个字段，多了一个字段而已。如果要实现我们的目标，即复用同一个接口来支持这两种业务的话，会有以下几种做法：<br>  (1) 用同一个接口，这个接口提供了所有数据。这样做的好处是实现起来简单，但缺点是对业务做判断的逻辑会增多，而且对于业务来说，响应内容中有些数据根本用不到；<br>  (2) 使用参数来区分不同的业务方并返回相应的数据。好处仍然是实现简单，虽然不会有用不到的数据返回，但是仍然需要增加业务逻辑判断，会造成以后维护的困难。<br>  (3) 以牺牲web端逻辑复杂度为代价，为web端再单独提供一个根据post查询comments的接口。</p>
<p>全部返回，服务器都需要去查询comments服务，即使移动端是不需要这个字段的，不但增加带宽，而且也造成了服务器压力增大，<br>增加参数字段，if…else区分返回，就会造成代码耦合，后期代码维护成本增加。</p>
<p>而GraphQL解决了这个问题，提供所有字段的resolve function，只要移动端的查询字段中不包含comments字段，则comment resolve function不会调用，所以也需要调用comment服务，自然也不会存在额外的服务器压力。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/webpack/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="苏三">
      <meta itemprop="description" content="一枚文科毕业，工作5+年的程序媛👨‍💻。">
      <meta itemprop="image" content="/images/common/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="苏三 • 博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/webpack/" class="post-title-link" itemprop="url">webpack扫盲</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-05-24 11:33:40 / 修改时间：14:08:02" itemprop="dateCreated datePublished" datetime="2019-05-24T11:33:40+08:00">2019-05-24</time>
            

            
              

              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <center><br>  <img src="/images/webpack/webpack.png" width="225" height="225"><br></center>

<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>很多前端项目都是直接使用提供的脚手架，包含较为完整的webpack配置，所以对webpack一直都是一知半解。前段时间将项目的webpack3升级到webpack4，借此机会对webpack进行扫盲。</p>
<h4 id="知识盲点总结"><a href="#知识盲点总结" class="headerlink" title="知识盲点总结"></a>知识盲点总结</h4><ol>
<li>style-loader、css-loader、file-loader<br>webpack 最出色的功能之一就是，除了 JavaScript，还可以通过 loader 引入任何其他类型的文件。<br>像以上罗列的三个loader能够让js里能使用import的方式，引入css或者image文件，<br>file-loader: 识别这是一个本地文件，并将 ‘./my-image.png’ 路径，替换为输出目录中图像的最终路径(文件名可能包括hash).</li>
<li>html-webpack-plugin<br>当webpack采用多入口(entry)或者输出文件名采用hash的方式，就会导致每次输出资源的url都是不同的，每次run build都需要相应的调整index.html。而HtmlWebpackPlugin这个插件就帮我们解决了这个痛点，可以自动生成index.html文件(当然也支持html模板生成，具体可参考<a href="https://github.com/jantimon/html-webpack-plugin" target="_blank" rel="noopener">配置</a>)，包含webpack输出的资源路径。</li>
<li>clean-webpack-plugin<br>在每次构建前清理 /dist 文件夹，保证dist文件夹只保留实际项目中用到的。</li>
<li>sourceMap开启<br>如果webpack将三个文件打包成一个bundle.js时，当其中一个源文件发生错误，那么堆栈跟踪信息只会简单的指向到bundle.js，无法知道错误的准确位置，而开启devtool: ‘inline-source-map’之后，就能帮我们准确的指明错误在源文件中的位置。在生产环境中使用’source-map‘，在开发环境中使用’inline-source-map’，source-map还有很多不同的<a href="https://www.webpackjs.com/configuration/devtool/" target="_blank" rel="noopener">选项</a>, 根据实际情况配置。</li>
<li>代码发生变化后自动编译<br>（1）watch观察者模式: 文件发生变化后，可以自动编译，但是需要手动刷新浏览器<br>（2）<a href="https://github.com/webpack/webpack-dev-server" target="_blank" rel="noopener">webpack-dev-server</a>：提供一个简单的web服务器，并且能够实时重新加载(live reloading)<br>（3）<a href="https://github.com/webpack/webpack-dev-middleware" target="_blank" rel="noopener">webpack-dev-middleware</a>: 它可以把 webpack 处理后的文件传递给一个服务器(server)，其实webpack-dev-server内部使用了它，可以启一个express服务试试。</li>
<li>tree shaking<br>通常用于描述移除 JavaScript 上下文中的未引用代码(dead-code)</li>
<li>DefinePlugin<br>允许创建一个在编译时可以配置的全局常量。比如用来定义当前运行的环境是development还是production.</li>
<li>代码分离<br>（1）入口起点 (entry)<br>（2）防止重复引用：CommonsChunkPlugin，可以对引用进行去重和分离chunk，<br>webpack4使用webpack.optimize.SplitChunksPlugin和RuntimePlugin进行公用代码分离<br>（3）动态导入：通过模块的内联函数调用来分离代码。<br>（4）分离出CSS文件：<a href="https://github.com/webpack-contrib/extract-text-webpack-plugin" target="_blank" rel="noopener">extract-text-webpack-plugin</a><br>它会将所有的入口 chunk(entry chunks)中引用的 *.css，移动到独立分离的 CSS 文件。在不使用改插件时，所有的css样式都被打包在JSbundle里。webpack4使用<a href="https://github.com/webpack-contrib/mini-css-extract-plugin" target="_blank" rel="noopener">mini-css-extract-plugin</a>替代.<br>（5）DllPlugin结合DllReferencePlugin插件</li>
<li>缓存<br>hash、chunkhash、contenthash的区别<br>hash一般是结合CDN缓存来使用，通过webpack构建之后，生成对应文件名自动带上对应的MD5值。如果文件内容改变的话，那么对应文件哈希值也会改变，对应的HTML引用的URL地址也会改变，触发CDN服务器从源服务器上拉取对应数据，进而更新本地缓存。<br>（1）hash：hash是跟整个项目的构建相关，只要项目里有文件更改，整个项目构建的hash值都会更改，并且全部文件都共用相同的hash值，这种方式有个缺陷，只要项目中有任何一个文件改变了，hash也会同时改变，所以所有文件都需重新拉取，达不到缓存的目的<br>（2）chunkhash：它根据不同的入口文件(Entry)进行依赖文件解析、构建对应的chunk，生成对应的哈希值。但是这个也有一个缺陷，就是当引用到的css没有变化时，由于处于同一个chunk，在业务处理变化是，css也达不到缓存的效果。<br>（3）contenthash：extra-text-webpack-plugin里的contenthash，保证即使css文件所处的模块里其他文件内容改变，只要css文件内容不变，那么不会重复构建。</li>
<li>webpack中常用的配置的区别：path、publicPath、contentBase<br>（1）output.path：webpack创建bundles存放的绝对路径<br>（2）publicPath：devServer里配置的publicPath指的是打包生成的静态资源文件所在的位置，而output.publicPath代表的是index.html文件里面引用资源的前缀<br>（3）contentBase：指查找index.html的位置，默认是当前执行的目录，一般是项目根目录。</li>
<li>path.join和path.resolve的区别<br>path.join将所有给定的path片段连接在一起，然后规范化生成路径。path.resolve将路径或路径片段的序列解析为绝对路径。resolve把”/“当成根目录。例子：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">path.join(<span class="string">'/foo/bar'</span>, <span class="string">'/tmp/file/'</span>)    <span class="comment">// /foo/bar/tmp/file/</span></span><br><span class="line">path.resolve(<span class="string">'/foo/bar'</span>, <span class="string">'/tmp/file/'</span>) <span class="comment">// /tmp/file</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><p><a href="https://www.webpackjs.com/configuration/devtool/" target="_blank" rel="noopener">https://www.webpackjs.com/configuration/devtool/</a><br><a href="https://juejin.im/post/5a4502be6fb9a0450d1162ed" target="_blank" rel="noopener">https://juejin.im/post/5a4502be6fb9a0450d1162ed</a><br><a href="https://juejin.im/post/5bb085dd6fb9a05cd24da5cf" target="_blank" rel="noopener">https://juejin.im/post/5bb085dd6fb9a05cd24da5cf</a></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/anti-pit/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="苏三">
      <meta itemprop="description" content="一枚文科毕业，工作5+年的程序媛👨‍💻。">
      <meta itemprop="image" content="/images/common/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="苏三 • 博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/anti-pit/" class="post-title-link" itemprop="url">防坑手册</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-01-23 17:22:39 / 修改时间：17:47:15" itemprop="dateCreated datePublished" datetime="2019-01-23T17:22:39+08:00">2019-01-23</time>
            

            
              

              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <center><br>  <img src="/images/anti-pit/kengdie.png" width="225" height="225"><br></center>

<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>Coding完的时候，总是蜜汁自信地觉得，我怎么这么牛*，这么复杂的逻辑都写出来了，提测后，会遇到各色各样的bug。然后debug了半天，恨不得骂自己一句：“傻*”。这不怪你，谁让js是世界上最牛*的语言，前端开发是宇宙中最牛*的职业呢，遇到点坑算啥，在同一个坑了跌倒两次才是真正的傻*。</p>
<h4 id="Array-prototype-sort"><a href="#Array-prototype-sort" class="headerlink" title="Array.prototype.sort()"></a>Array.prototype.sort()</h4>
          <!--noindex-->
          
            <div class="post-button text-center">
              <a class="btn" href="/anti-pit/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          
          <!--/noindex-->
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/session/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="苏三">
      <meta itemprop="description" content="一枚文科毕业，工作5+年的程序媛👨‍💻。">
      <meta itemprop="image" content="/images/common/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="苏三 • 博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/session/" class="post-title-link" itemprop="url">express-session关键源码解读</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-01-16 14:42:55" itemprop="dateCreated datePublished" datetime="2019-01-16T14:42:55+08:00">2019-01-16</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-01-18 16:22:23" itemprop="dateModified" datetime="2019-01-18T16:22:23+08:00">2019-01-18</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/前端/" itemprop="url" rel="index"><span itemprop="name">前端</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p><del>有个测试的同学可能在搞自动化测试还是啥的，然后想要用python调网关接口，但是一直调不通，问我需要携带哪些信息，可以通过校验。我跟她说请求时携带用户信息和登录的auth信息就可以了，结果发现还是不想，网关的session信息一直是空的。一开始想的是跨域，导致没有携带cookie，让测试配置credentials: ‘include’(<a href="../cors">参考文章</a>)，对python一窍不通的两人，不知道python咋设置，后来就干脆直接写了个接口/api/getCookie让测试拿cookie，手动设置请求头的cookie，最后发现session还是为空，因为请求既然已经带着cookie了，那一定是根据这个cookie里的sessionId去查找，测试在调/api/getCookie是没有设置session的，走接下来的流程，肯定还是空的，最终改成在调/api/getCookie接口是，先设置下session，后期session如果有更新，再去更新store。</del></p>
<p><del>虽然方法有点挫，但是不能妨碍我学习的脚步。</del><br>update: 之前一直有疑惑，为啥测试调我开发环境可以，调测试环境不行，还不报错，今天空下来，写了个python请求的demo，发现之前认知的偏差。压根就不是python不能携带cookie引发的一系列骚操作，而是因为网关层某个session值在replace之前没有设置，然后，然后抛异常了。。。。没看到异常日志，只怪我太瞎了。</p>
<p><del>之所以道路那么曲折，还不是因为对基础不扎实，对第三方库不熟悉，所以仔细的看了下session相关的文章，以及express-session源码。</del><br>虽然道路曲折，但是也算有所收获了~~~</p>
          <!--noindex-->
          
            <div class="post-button text-center">
              <a class="btn" href="/session/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          
          <!--/noindex-->
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/cors/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="苏三">
      <meta itemprop="description" content="一枚文科毕业，工作5+年的程序媛👨‍💻。">
      <meta itemprop="image" content="/images/common/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="苏三 • 博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/cors/" class="post-title-link" itemprop="url">跨域预检请求</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-12-29 23:07:35" itemprop="dateCreated datePublished" datetime="2018-12-29T23:07:35+08:00">2018-12-29</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-01-17 14:57:29" itemprop="dateModified" datetime="2019-01-17T14:57:29+08:00">2019-01-17</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/前端/" itemprop="url" rel="index"><span itemprop="name">前端</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>遇到问题的过程中，很多人优先想到的是如何去解决，而不是说为什么会出现这种现象，毕竟留给程序员的时间不多，就把”为什么”留给空下来的时候，再去好好研究吧，然后留着留着就忘记这一茬了。当然，以上仅代表个人观点，因为我就是这样的人，现在，我决定把某一茬捡起来。</p>
<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>有一天，有个同事遇到个问题(具体啥问题记不清了)，然后找另外一个同事帮她看，然后另外一个同事说：你不知道跨域访问，会有一个OPTIONS的请求么？我在旁边听到的时候，心想：我知道会有个OPTIONS，但是为什么呢？</p>
          <!--noindex-->
          
            <div class="post-button text-center">
              <a class="btn" href="/cors/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          
          <!--/noindex-->
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/float/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="苏三">
      <meta itemprop="description" content="一枚文科毕业，工作5+年的程序媛👨‍💻。">
      <meta itemprop="image" content="/images/common/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="苏三 • 博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/float/" class="post-title-link" itemprop="url">Javascript浮点数存储及误差问题</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-12-25 19:50:37" itemprop="dateCreated datePublished" datetime="2018-12-25T19:50:37+08:00">2018-12-25</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-01-17 14:56:27" itemprop="dateModified" datetime="2019-01-17T14:56:27+08:00">2019-01-17</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/前端/" itemprop="url" rel="index"><span itemprop="name">前端</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>钉钉告警群不断提示”批量支付不支持调整金额”，但是按照正常的业务逻辑，批量支付根本不会出现调整金额的入口。由于该需求非本人开发的，也没放在心上，后来在聊天过程中，聊到是因为前端参数将元-&gt;分(如9956.8*100=995679.9999999999)传给网关及服务的时候，服务做了兜底，判断前端传的价格跟服务不一致，则判定为调整过金额了，尴了个尬。<br>
          <!--noindex-->
          
            <div class="post-button text-center">
              <a class="btn" href="/float/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          
          <!--/noindex-->
        
      
    </p></div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/testing/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="苏三">
      <meta itemprop="description" content="一枚文科毕业，工作5+年的程序媛👨‍💻。">
      <meta itemprop="image" content="/images/common/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="苏三 • 博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/testing/" class="post-title-link" itemprop="url">Jest + enzyme 前端测试入门</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-12-06 20:29:24" itemprop="dateCreated datePublished" datetime="2018-12-06T20:29:24+08:00">2018-12-06</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-01-17 14:56:45" itemprop="dateModified" datetime="2019-01-17T14:56:45+08:00">2019-01-17</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/前端/" itemprop="url" rel="index"><span itemprop="name">前端</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>留给程序员的时间，永远都不够开发的，哪有时间写单元测试？<br>为什么要选Jest作为单元测试框架？<br>单元测试有啥用？<br>
          <!--noindex-->
          
            <div class="post-button text-center">
              <a class="btn" href="/testing/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          
          <!--/noindex-->
        
      
    </p></div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/modules/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="苏三">
      <meta itemprop="description" content="一枚文科毕业，工作5+年的程序媛👨‍💻。">
      <meta itemprop="image" content="/images/common/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="苏三 • 博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/modules/" class="post-title-link" itemprop="url">聊聊CommonJS、ES6模块、Webpack及Babel</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-10-25 15:41:09" itemprop="dateCreated datePublished" datetime="2018-10-25T15:41:09+08:00">2018-10-25</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-11-05 21:58:09" itemprop="dateModified" datetime="2018-11-05T21:58:09+08:00">2018-11-05</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/前端/" itemprop="url" rel="index"><span itemprop="name">前端</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>什么是模块？为什么要模块化？架构师或者比你牛逼的攻城狮搭建好架构后，只知道项目中粘贴代码，不知道何时用require，何时用import，何时用export，何时用module.exports？耐心的看完这篇文章，希望一脸懵逼的你们，能有所获。<br>
          <!--noindex-->
          
            <div class="post-button text-center">
              <a class="btn" href="/modules/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          
          <!--/noindex-->
        
      
    </p></div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/common/avatar.jpg" alt="苏三">
            
              <p class="site-author-name" itemprop="name">苏三</p>
              <p class="site-description motion-element" itemprop="description">一枚文科毕业，工作5+年的程序媛👨‍💻。</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">9</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                    <span class="site-state-item-count">1</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">18</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com/susan-github" title="GitHub &rarr; https://github.com/susan-github" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://www.jianshu.com/u/e6981e9cdded" title="简书 &rarr; https://www.jianshu.com/u/e6981e9cdded" rel="noopener" target="_blank"><i class="fa fa-fw fa-book"></i>简书</a>
                </span>
              
            </div>
          

          

          
          

          
            
          
          

        </div>
      </div>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">苏三</span>

  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> v6.6.0</div>





    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <div>
      <span id="busuanzi_container_site_pv">本站总访问量:<span id="busuanzi_value_site_pv"></span>次</span>
      <span class="post-meta-divider">|</span>
      <span id="busuanzi_container_site_uv">本站访客数:<span id="busuanzi_value_site_uv"></span>人</span>
      <span class="post-meta-divider">|</span>
      <span id="busuanzi_container_page_pv">本文总阅读量:<span id="busuanzi_value_page_pv"></span>次</span>
    </div>


        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script src="/js/src/utils.js?v=6.6.0"></script>

  <script src="/js/src/motion.js?v=6.6.0"></script>



  
  

  

  


  <script src="/js/src/bootstrap.js?v=6.6.0"></script>



  



  











  

  <script>
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  

  

  
  

  

  

  

  

  

  

  <!-- 代码块复制功能 -->
  <script type="text/javascript" src="/js/src/clipboard/clipboard.min.js"></script>  
  <script type="text/javascript" src="/js/src/clipboard/clipboard-use.js"></script>
</body>
</html>
